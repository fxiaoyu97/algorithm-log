# 散列表

## 散列思想

散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展。查询效率接近`O(1)`，跟散列函数、装载因子、散列冲突等有关系。

## 散列函数

定义为`hash(key)`，key 表示元素的键值，`hash(key)`表示经过散列函数计算得到的散列值。

散列函数设计的基本要求：

1. 散列函数计算得到的散列值是一个非负整数
2. 如果 `key1 = key2`, 那么 `hash(key1) == hash(key2)`；
3. 如果 `key1 != key2`, 那么 `hash(key1) != hash(key2)`；

## 散列冲突

### 装载因子

用来表示散列表中空位的多少。` 散列表的装载因子 = 填入表中的元素个数 / 散列表的长度 `，装载因子越大说明空闲位置越少，冲突越多，散列表的性能会下降。

### 1、开放寻址法

如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入 。

#### 1.1 线性探测

当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了， 我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。 

**删除时比较特别**，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效，我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的 空间，并不是停下来，而是继续往下探测。 

线性探测法其实存在很大问题。当散列表中插入的数据越来越多时，散列冲 突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况 下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。

#### 1.2 二次探测

线性探测每次探测的步长是 1 ，二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+1^2，hash(key)+2^2 …… 

#### 1.3 双重散列

使用一组散列函数 hash1(key)， hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用， 再用第二个散列函数，依次类推，直到找到空闲的存储位置。 

### 2、链表法

在散列表中每个“槽”会对应一条链表，所有散列值相同的元素我们放在相同的槽位对应的链表中。插入数据的时间复杂度为`O(1)`，

查找和删除的时间复杂度跟链表的长度 k 有关，也就是`O(K)`，当散列表比较均匀是，理论上 k=n/m，其中 n 表示散列表中数据的个数，m 表示散列表中“槽”的个数。

当所有的元素集中到一个链表中时，散列表就会退化成链表，查询时间会退化成`O(n)`

## 如何设计散列函数

1. 散列函数的设计不能太复杂，复杂的函数影响散列表的性能
2. 散列函数生成的值要尽可能随机并且均匀分布，避免散列冲突

## 装载因子过大

1. 再能确定元素数量的情况下，可以申请一个容量合适的散列表，设计哈希值重复少的散列函数。
2. 在事先无法确定元素数量的情况下，就要构建一个能扩容的动态散列表。散列表随着元素的变多，散列冲突出现的概率会越来越大，当装载因子达到一个阈值时，这时候就要考虑扩容了。

这种扩容机制类似于的集合的动态扩容，但是复杂度要比集合高，更换新的散列表，需要重新计算元素的键值，大量元素的迁移需要耗费太多的时间，迁移元素的时间复杂度为`O(n)`，正常插入数据的时间复杂度为`O(1)`，那么算下的均摊时间复杂度为`O(1)`，这个时间复杂度在理论上是比较好的。 

但是这里有一个问题，在实际操作过程中，扩容会在某次插入元素时进行，假如要迁移的元素有几百万甚至上千万，那么这次插入操作的耗时将是十分漫长的，那么是不是有更优雅的方法解决问题呢？

方法还是有的
