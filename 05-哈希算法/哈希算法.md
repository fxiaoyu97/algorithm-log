# 哈希算法（开盲盒）

将任意长度的二进制值串因映射成固定长度的二进制值串，这个映射规则就是**哈希算法**。通过原始数据映射得到的二进制串就是**哈希值**。

## 优秀哈希

一个优秀的哈希算法的特点：

1. 不能从哈希值反向推导出原始数据（所以哈希算法也叫单向哈希算法）
2. 对输入数据非常敏感，原始数据修改一个 Bit 得到的哈希值也应该大不相同。
3. 散列冲突的概率要很小，不同的原始数据，哈希值相同的概率要非常小。
4. 哈希算法的执行效率要高效，较大的文件也能快速计算出哈希值

## 应用场景

### 散列函数

最容易想到的肯定就是散列表中的散列函数，通过散列函数获取哈希值，散列函数是散列表中很重要一环。在散列函数中，有解决散列冲突的方法，所以减少散列冲突的不是重点。更重要的是散列函数的效率问题，这决定了散列表的性能问题。

### 安全加密

加密的哈希算法：MD5 （MD5 Message-Digest Algorithm，MD5 消息摘要算法）和 SHA（Secure Hash Algorithm，安全散列算法）。

**哈希算法无法做到零冲突**，十三个人中必然会有两个人的在同一月出生。同样的道理，MD5的哈希值是128位的二进制串，能表示 2^128 个数据，数据量超过这个数值时就会有有两个数据的哈希值相同。

哈希算法虽然不能反向解析数据，但是可以通过穷举的方法比对计算后得到的哈希值是否相同，进而获取原始数据，所以MD5加密的密码之类的并不是可靠的，加密也没有绝对的安全。

### 唯一标识

都用过网盘吧，我们有时候往网盘里面上传文件，有时候可以做到秒传，是不是还以为自己的网速超级快？醒醒吧，你那只是办手机卡送的宽带。

其实，如果有些文件被其他人上传过，那么软件只要扫描一遍你的文件，就能判断两个文件是否相等，如果相等的话，就把已经上传过的那个文件复制一个链接放到你的网盘上，然后传输结束了。

那么问题来了，学习视频那么多，一个视频几百兆甚至几个GB，而且命名还不一样，如果是使用二进制字节去对比的话，肯定是特别慢，那么是怎么能在短时间内判断两个命名不同的文件是否为同一个文件的呢？

这就要谈到哈希算法了，文件在计算机中是以二进制方式存储的，最简单的思路就是使用哈希算法（比如 MD5），计算文件哈希值，用这个值作为文件的唯一标志，然后通过与其他文件进行比较，确定两个文件是否为同一文件。

这只是最简单的原型算法，实际应用肯定更加复杂一些，毕竟有一定几率存在哈希值相同的不同文件。也可以增加对比的次数解决，比如截取文件其中一部分的，计算哈希值进行对比，对此对比确定文件是否相同。这只是猜测，有大佬了解的话，可以告知一二。

### 数据校验

不知道有多少小伙伴给妹子的电脑安装过操作系统？不知道又有多少小伙伴遇到过安装过程中因为镜像损坏而安装失败的尴尬情况？下载镜像的过程中没有什么问题，这景象怎么就坏事了呢？

我们一般都是使用迅雷或者IDM这种多线程下载工具下载文件， 这相当于并行下载了一个镜像文件，下载的文件那是七零八散的，所有的文件下载完成以后再重新组装在一起。这时候怎么确认你下载的就是原来的文件呢？

网站在提供文件的同时，还提供了一个 MD5 的哈希值字符串，这时候我们可以对下载的文件进行处理，使用 MD5 算法计算出它的哈希值，对比计算出的哈希值和网站提供的哈希值是否相等，如果相等则表示下载文件没有问题，如果不同，那么下载的文件损坏了。

### 负载均衡 - 会话粘滞（银行业务）

同一个客户端的所有请求都路由到同一个服务器上，也就是会话粘滞（session sticky）的负载均衡算法。

最简单的就是在数据库创建一张映射表，维护会话ID和服务器的映射关系，客户端发出的每次请求，都要在映射表中查找需要路由的服务器编号，然后通过把请求发给对应编号的服务器上面，方法实现比较简单，但是有两个问题：

1. 维护映射表需要额外的空间，随着会话ID的越来越多，占用的空间也会越来越多；
2. 服务器的下线和上线都会对映射表产生影响，这时候需要重新维护映射表的，维护成本比较大。

通过哈希算法，对客户端地址或者会话ID 计算哈希值，将取得的哈希值和服务器列表的数量进行取模运算，最终得到的值就是应该被路由到的服务器编号。这样也可以保证同一个客户端过来的所有请求路由到同一个后端服务器上。

### 数据分片 - 快速判断图片是否在图库中

通过对图片信息进行提取，获取唯一标志，构建散列表，然后就可以通过判断新图片的唯一标志是否在散列表中，确认新图片是否在图库中存在。

如果构建散列表需要的空间超过了机器的内存，这时候就要增加多台机器了，然后把数据分给多台机器处理，每台主机构建一部分图片的散列表。

往里面添加一个新的图片时，可以通过哈希计算获取的图片的哈希值，然后与机器的个数 n 求模，得到的值就为要存放图片的机器编号。

判断一个图片是否在图库中存在时，通过同样的哈希算法，获取这个图片的哈希值，然后与机器的个数 n 求模，得到值 k，然后去编号为 k 机器上的散列表中查找。

**估算一亿张图片构建散列表大概需要多少台机器？**

散列表中存放的每个数据单元需要包含两个信息，哈希值和图片文件的路径，假设使用 MD5 计算哈希值，那么哈希值的长度就是`128位(bit)`，也就是`16字节(B)`，文件路径长度的上限是 `256B`，我们可以假设平均长度是`128B`，如果我们使用链表法解决散列冲突，那么还需要存储冲突，那还需要存储指针，指针只占用`8B`，所有散列表中每个单元就占用`152B`。（估算值）

假设一台服务器的可用内存大小为4GB，散列表的负载因子为 0.75，那么一台机器大约可以构建两千万（`4GB*0.75/152B`）照片的散列表。

所以对一亿张图片构建散列表索引，大约需要五六台机器，在工程中，估算项目需要的成本，可以让我们实现对需要投入的资源、自检有个大概的了解，能更好的评估解决方案的可行性。

面对海量的数据是，对资源进行分片的分布式处理，可以突破单机性能的限制。