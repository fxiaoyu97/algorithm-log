# 跳表

一种动态数据结构，在链表的基础上创建，使其查找速度类似于二分查找。Redis的有序集合使用跳表实现。

链表自身的查找效率比较低，时间复杂度为`O(n)`

可以建立索引层提高效率，每间隔数个节点，提取一个节点作为索引节点，搜索数据时，可以先从索引层开始。一级索引上还可以建立二级索引。

## 时间复杂度

每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 `n/(2^k)`。

假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 `n/(2^h)=2`，从而 求得 `h=log2(n)-1`。如果包含原始链表这一层，整个跳表的高度就是 `log2(n)`。

我们在跳表中查询某 个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 `O(m*logn)`。 那这个 m 的值是多少呢？按照前面这种索引结构，我们每一级索引都最多只需要遍历 3 个结 点，也就是说 m=3，为什么是 3 呢？

## 空间复杂度

假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。 

点总和就是 n/2+n/4+n/8…+8+4+2=n-2。所以，跳表的空间复杂度是 O(n)。 如果将包含 n 个结点的单链表构造成跳表，我们需要额外再用接近 n 个结点的存储 空间。 

那我们有没有办法降低索引占用的内存空间呢？ 我们前面都是每两个结点抽一个结点到上级索引，如果我们每三个结点或五个结点，抽一个结点 到上级索引，是不是就不用那么多索引结点了呢？ 

总的索引结点大约就是 n/3+n/9+n/27+…+9+3+1=n/2。尽管空间复 杂度还是 O(n)，但比上面的每两个结点抽一个结点的索引构建方法，要减少了一半的索引结点 存储空间。 

## 插入和删除

跳表这个 动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 `O(logn)`。

插入和删除操作类似于查找，需要找到数字位置。

## 跳表索引动态更新

防止极端情况下，跳表退化成单链表，跳表使用随机函数维护平衡型，插入数据时，随机产出要涉及修改的索引层数。

## 编程思想

### 跳表

1. 最大的层数，MAX_LEVEL
2. 存在多少层索引，levelCount
3. 带头链表，头结点 head，不存放数据
4. 节点，记作 Node
5. 查找、插入、删除、随机层数生成等方法

### 节点

表示在跳表中，每个节点存放的内容有哪些

1. 存放的数据，记做 data
2. 当前节点在不同层数时的后继节点，记做 `Node forwards[]`，例如`forwards[3]`表示当前节点在第三层的下一个节点
3. 节点存在的层数，此节点总共在多少层索引中存在，记做 level

### 插入方法

插入一个新的数据，不仅要在链表中放入新数据，还需要维护索引，为了避免索引出现间隔比较长的情况，一般使用随机层数。

1. 生成随机层数
2. 创建新的节点
3. 查找每层需要更新后继节点的节点，做记录，判断条件：**此节点的值小于新节点，后继节点的值大于新节点，需考虑边界问题，注意判断后继节点是否为`null`**
4. 更新这些节点的后继节点为新节点，同时更新新节点的后继节点
5. 更新最大层数

### 优化插入方法

1. 产生随机层数，如果为空链表，层数为1
2. 判断随机层数值，如果大于当前索引的数量，随机层数改为当前索引层数+1，当前索引层数也需要+1
3. 创建新节点
4. 设需要修改后继节点的节点为 p，`p=head`，从最上层开始往下遍历，当找到第一个需要修改的节点时，该节点前面的节点都不再需要比较。再往下遍历时，可以以这个为前提，不再遍历之前的数据。
5. 判断节点是否为临界点（后继节点为null），如果是的，直接在其后面拼接新节点；否则的话，在两个节点中间插入新节点

### 查找&删除

方法类似查找，在插入新节点的时候就是用来查找的方法。**从最上层开始往下查找。**最后的判断条件变成是否相等，注意临界条件。

删除的时候需要同步更新各层索引的后继节点。
