## 图

非线性表数据结构，树中的元素叫作节点，图中的元素叫作**顶点**。

图中两个顶点之间的连接线叫作**边**。

跟顶点相连接的边德条数叫作顶点的**度**。

边上有方向的图叫作**有向图**，边上没有方向的图叫作**无向图**。

### 有向图

度分为**入度**和**出度**

顶点的入度，表示有多少条边指向这个顶点；顶点的出度表示有多少条边以这个顶点为起点指向其他顶点。比如小红书的单向关注，微信的单向好友机制。

### 带权图

类似QQ好友之间的亲密度，在表示好友的基础上，每条边加上一个权重(weight)。

## 存储方法

### 邻接矩阵存储方法

图的最直观的一种存储方法就是：**邻接矩阵（Adjacency Matrix）**

邻接矩阵的底层依赖是一个二维数组，在无向图中，如果顶点 i 与顶点 j 之间有边，我们就将`A[i][j]` 和 `A[j][i]`标记为 1；在有向图中，如果有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 `A[i][j]`标记为 1，如果没有箭头从顶点 j 指向顶点 i ，那么`A[j][i]`就标记为 0 ；在带权图中，存储的不再是 0 和 1 ，而是对应的权重。

邻接矩阵的存储方式比较简单和直接，基于数组实现，获取顶点的关系时，非常高效。计算起来也比较简单。

缺点就是浪费空间，当存储是**稀疏图（顶点很多，但是每个顶点的边并不多）**时，这种存储方式就比较浪费空间。

### 邻接表存储方式

解决邻接矩阵比较浪费内存空间的问题——**邻接表（Adjacency List）**

邻接表有点像散列表，每个顶点对应一条链表，链表中存储的时与这个顶点相连接的其他顶点。

这是一种空间与时间复杂度互换的设计思想，邻接矩阵浪费时间，使用比较方便，邻接表存储比较省空间，但是使用起来比较耗时。

在邻接表中确定两个顶点是否相连，需要遍历顶点对应的那条链表，链表的存储方式对缓存也不友好，可以利用解决散列表中链过长的方法，提高查找效率。把链表换成平衡二叉查找树，跳表等数据结构。
