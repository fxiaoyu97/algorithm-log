# 归并排序

采用**分治思想**，对将要排序的数组分为左右两部分，然后对左右两部分数据分别进行排序，再将排好序的数据合并在一起。

**分治是一种解决问题的处理思想， 递归是一种编程技巧。**分治就是把一个大问题分解成子问题，子问题的解决方式和大问题相同，小的问题解决了，大问题也就解决了。

## 解决思路

1. 找出大问题和小问题解决时的共同方法
2. 使用伪代码写出简单的递推公式
3. 注意边界问题，临界的结束点，如数组的长度为1，或者起始位置和终止位置相同

```
递推公式
merSort(p…r)=merge(mergeSort(p…q),mergeSort(q+1…r))

终止条件：
p >= r 不再继续分解

// A表示数组，p表示起始位置，r表示结束位置
mergeSort(A, p, r){
	// 递归终止条件
    if p>= r then return
    
    // 获取p和r之间的中间位置q
    q = (p+r)/2
    // 分治递归
    mergeSort(A, p, q)
    mergeSort(A, q+1,r)
    // 将A[p…q] 和 A[q+1…r] 合并为A[p…r]
    merge(A[p…r], A[p…q], A[q+1…r])
}
```



## 归并排序的性能分析 

### 稳定的排序算法

归并排序可以保证值相同的元素，在合并前后的先后顺序不变，所以，**归并排序是一个稳定的排序算法**。

### 时间复杂度

不仅递归求解的问题可以写成递推公式，递归代 码的时间复杂度也可以写成递推公式 。

```
T(1) = C; n=1时，只需要常量级的执行时间，所以用C表示
T(n) = 2*T(n/2) + n; n>1

T(n) = 2*T(n/2) + n
     = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
     = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
     ……
     = 2^k * T(n/2^k) + k * n
     ……
```

最后我们可以得到`T(n)=2^kT(n/2^k)+kn`，当`T(n/2^k)=T(1)`时，也就是`n/2^k=1`，这时候可以得到`k=log2(n)`，把k值代入上面的工时，得到`T(n)=Cn+nlog2(n)`，使用大O表法，得到的时间复杂度为`O(nlogn)`。

### 空间复杂度 

归并排序不是原地排序算法。

每次合并操作都需要申请额外的内存空间，合并完成之后，临时开辟的内存空间就被释放掉了。

在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以**空间复杂度是 O(n)**。
