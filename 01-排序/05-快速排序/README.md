# 快速排序

分治思想，找出排序数组中的一个数据做为分区点，小于分区点的数据放在左边，大于分区点的数据放到右边，分区点放在中间。

根据分治、递归的处理思想，不断地缩小需要排序的数组区间，直到区间数据数量为1。

## 解决思路

1. 找出解决问题时大小问题相同的方法
2. 使用伪代码写出简单的递推公式
3. 注意边界问题，临界的结束点，结束时的标志

```
递推公式：
quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1,r)
终止条件：
p >= r
```

伪代码实现：

```
// 快速排序，A是数组，n表示数组大小
Solution(A, n){
    quick_sort(A, 0, n-1)
}
// 快速排序递归函数，p,r为下标
quick_sort(A, p, r){
    if p >= r then return
    
    // 获取分区点再数组中的坐标
    q = partition(A, p, r)
    quick_sort(A, p, q-1)
    quick_sort(A, q+1, r)
}
```

`partition()`分区函数的实现，实现的方法如下所示：选择最后一个元素作为分区点，使用左右两个相反游标移动比较数据大小，当左边游标遇到比分区点大的数据，右游标遇到比分区点小的数据时，两者交换位置，当左右游标相遇时，比较结束，把相遇的位置与分区点交换。

也可以使用相同方向的游标处理数据，一个查找大数据，一个查找小数据，当遇到大数据时，暂停移动，小数据游标继续移动，往前遇到小数据时，两者交换。

## 快速排序的性能分析

### 稳定的排序算法

快速排序有可以让值相同的元素颠倒位置，所以，**快速排序不是一个稳定的排序算法**。

### 时间复杂度

`T(n)` 在大部分情况下的时间复杂度都可以做到 `O(nlogn)`，只有在极端情况 下，才会退化到 `O(n^2)`。 

### 空间复杂度

快速排序可以做到空间复杂度为常量级别，是原地排序算法。
